import {EntityType} from "./entitiy-type";

export interface CustomEnumOperations<EnumStrings extends string> extends EntityType<EnumStrings> {
  readonly ENUM_TYPE: EnumStrings;

  offNumber(nr: number): EnumStrings | undefined;

  offName(name: EnumStrings): number | undefined;
}

export type CustomEnum<EnumStrings extends string> = {
  readonly [k in EnumStrings]: k;
} & CustomEnumOperations<EnumStrings>;

export const createEnum = <EnumStrings extends string>(...args: EnumStrings[]) => {
  const validStr = args.join(", ");

  const ret: CustomEnumOperations<EnumStrings> = {
    ENUM_TYPE: null as unknown as EnumStrings, // this is a helper to export the typing generated by the varargs
    isValidValue(name: any): name is EnumStrings {
      return args.includes(name);
    },
    offNumber(nr: number) {
      return args[nr];
    },
    offName(name: EnumStrings) {
      const index = args.indexOf(name);
      return index == -1 ? undefined : index;
    },
    getValidAsString(): string {
      return validStr;
    },
    getAllValid(): ReadonlyArray<EnumStrings> {
      return args;
    },
    [Symbol.iterator]() {
      return args[Symbol.iterator]();
    },
  };

  for (const t of args) (ret as any)[t] = t;

  Object.freeze(ret);
  Object.freeze(args);

  return ret as CustomEnum<EnumStrings>;
};
